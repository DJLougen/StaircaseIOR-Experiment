<!DOCTYPE html>
<html>
<head>
    <title>Psi Method IOR Crossover Experiment</title>
    <script src="https://unpkg.com/jspsych@7.3.4"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-fullscreen@1.2.1"></script>
    <script src="https://unpkg.com/@jspsych/plugin-call-function@1.1.3"></script>
    <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" type="text/css" />
    <style>
        body {
            background-color: black;
        }
        .jspsych-content {
            max-width: 100%;
        }
        .jspsych-content-wrapper {
            background-color: black;
        }
        .trial-container {
            position: relative;
            width: 800px;
            height: 400px;
            margin: 0 auto;
            background-color: black;
        }
        .fixation {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: white;
            font-family: Arial, sans-serif;
        }
        .box {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 3px solid white;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
        }
        .left-box {
            left: 150px;
        }
        .right-box {
            right: 150px;
        }
        .cue, .target {
            position: absolute;
            width: 74px;
            height: 74px;
            background-color: white;
            top: 50%;
            transform: translateY(-50%);
        }
        .cue-left, .target-left {
            left: 153px;
        }
        .cue-right, .target-right {
            right: 153px;
        }
        .instructions {
            color: white;
            font-size: 20px;
            line-height: 1.6;
            max-width: 700px;
            margin: 0 auto;
            text-align: left;
        }
        .instructions h2 {
            text-align: center;
        }
        .continue-text {
            text-align: center;
            margin-top: 30px;
            color: #aaa;
        }
        .feedback {
            color: white;
            font-size: 32px;
            text-align: center;
        }
        .feedback.error {
            color: #ff6666;
        }
        .results {
            color: white;
            font-size: 24px;
            line-height: 1.8;
            text-align: center;
        }
    </style>
</head>
<body></body>
<script>
// =============================================================================
// PSI METHOD IOR CROSSOVER EXPERIMENT - jsPsych Version
// =============================================================================
// This experiment uses the Psi adaptive method (Kontsevich & Tyler, 1999) to
// efficiently find the IOR crossover point (ISI where cued RT = uncued RT).
//
// The Psi method maintains a Bayesian posterior over threshold and slope
// parameters, and selects each stimulus to maximize expected information gain.
//
// Advantages over traditional staircase:
// - Faster convergence (typically 30-50 trials vs 60-100)
// - Provides uncertainty estimates
// - Optimal stimulus placement
// =============================================================================

// --- Psi Method Parameters ---
const MIN_ISI = 50;
const MAX_ISI = 600;
const N_ISI_LEVELS = 23;        // Number of ISI levels to consider (grid resolution)
const N_THRESHOLD_LEVELS = 30;   // Grid resolution for threshold parameter
const N_SLOPE_LEVELS = 15;       // Grid resolution for slope parameter

// Slope range (controls steepness of psychometric function)
const MIN_SLOPE = 20;   // Steep transition
const MAX_SLOPE = 150;  // Gradual transition

// Stopping criteria
const N_TRIALS_MIN = 30;         // Minimum trials before stopping
const N_TRIALS_MAX = 80;         // Maximum trials
const CONFIDENCE_THRESHOLD = 0.90; // Stop if 90% of posterior within 30ms range

// --- Timing Parameters (in ms) ---
const FIXATION_DURATION = 750;
const CUE_DURATION = 50;
const TARGET_DURATION = 1000;

// --- Practice Parameters ---
const N_PRACTICE_TRIALS = 0;  // Disabled for testing
const PRACTICE_ISIS = [50, 150, 250];

// --- RT Collection Parameters ---
const RT_WINDOW = 5;  // Collect 5 valid + 5 invalid RTs before making observation

// =============================================================================
// PSI METHOD IMPLEMENTATION
// =============================================================================

// Create parameter grids
function linspace(start, end, n) {
    const step = (end - start) / (n - 1);
    return Array.from({ length: n }, (_, i) => start + i * step);
}

const isiLevels = linspace(MIN_ISI, MAX_ISI, N_ISI_LEVELS);
const thresholdLevels = linspace(MIN_ISI, MAX_ISI, N_THRESHOLD_LEVELS);
const slopeLevels = linspace(MIN_SLOPE, MAX_SLOPE, N_SLOPE_LEVELS);

// Psychometric function: P(IOR | ISI, threshold, slope)
// Uses logistic function: higher ISI = more likely to observe IOR
function psychometricFunction(isi, threshold, slope) {
    return 1 / (1 + Math.exp(-(isi - threshold) / slope));
}

// Psi state object
let psi = {
    // Prior/posterior over [threshold, slope] - 2D array
    posterior: null,

    // RT collection for current observation
    validRTs: [],
    invalidRTs: [],

    // History
    isiHistory: [],
    observationHistory: [],  // 1 = IOR observed, 0 = facilitation observed

    // Current trial ISI (selected by Psi)
    currentISI: null,

    // Observation count
    nObservations: 0
};

// Initialize uniform prior
function initializePsi() {
    const nThresh = thresholdLevels.length;
    const nSlope = slopeLevels.length;
    const uniformProb = 1 / (nThresh * nSlope);

    psi.posterior = Array(nThresh).fill(null).map(() =>
        Array(nSlope).fill(uniformProb)
    );

    // Start with middle ISI
    psi.currentISI = isiLevels[Math.floor(isiLevels.length / 2)];
}

// Calculate expected entropy for a given ISI
function expectedEntropy(isi) {
    const nThresh = thresholdLevels.length;
    const nSlope = slopeLevels.length;

    // Calculate P(IOR | ISI) by marginalizing over posterior
    let pIOR = 0;
    for (let t = 0; t < nThresh; t++) {
        for (let s = 0; s < nSlope; s++) {
            const pFunc = psychometricFunction(isi, thresholdLevels[t], slopeLevels[s]);
            pIOR += psi.posterior[t][s] * pFunc;
        }
    }
    const pFacilitation = 1 - pIOR;

    // Calculate entropy of posterior after observing IOR
    let entropyAfterIOR = 0;
    if (pIOR > 1e-10) {
        for (let t = 0; t < nThresh; t++) {
            for (let s = 0; s < nSlope; s++) {
                const pFunc = psychometricFunction(isi, thresholdLevels[t], slopeLevels[s]);
                const posteriorGivenIOR = (psi.posterior[t][s] * pFunc) / pIOR;
                if (posteriorGivenIOR > 1e-10) {
                    entropyAfterIOR -= posteriorGivenIOR * Math.log2(posteriorGivenIOR);
                }
            }
        }
    }

    // Calculate entropy of posterior after observing facilitation
    let entropyAfterFac = 0;
    if (pFacilitation > 1e-10) {
        for (let t = 0; t < nThresh; t++) {
            for (let s = 0; s < nSlope; s++) {
                const pFunc = psychometricFunction(isi, thresholdLevels[t], slopeLevels[s]);
                const posteriorGivenFac = (psi.posterior[t][s] * (1 - pFunc)) / pFacilitation;
                if (posteriorGivenFac > 1e-10) {
                    entropyAfterFac -= posteriorGivenFac * Math.log2(posteriorGivenFac);
                }
            }
        }
    }

    // Expected entropy = weighted average
    return pIOR * entropyAfterIOR + pFacilitation * entropyAfterFac;
}

// Select optimal ISI (minimizes expected posterior entropy)
function selectOptimalISI() {
    let minEntropy = Infinity;
    let bestISI = isiLevels[Math.floor(isiLevels.length / 2)];

    for (const isi of isiLevels) {
        const entropy = expectedEntropy(isi);
        if (entropy < minEntropy) {
            minEntropy = entropy;
            bestISI = isi;
        }
    }

    return bestISI;
}

// Update posterior after observation
function updatePosterior(isi, observedIOR) {
    const nThresh = thresholdLevels.length;
    const nSlope = slopeLevels.length;

    // Calculate likelihood for each parameter combination
    let totalProb = 0;
    const newPosterior = Array(nThresh).fill(null).map(() => Array(nSlope).fill(0));

    for (let t = 0; t < nThresh; t++) {
        for (let s = 0; s < nSlope; s++) {
            const pFunc = psychometricFunction(isi, thresholdLevels[t], slopeLevels[s]);
            const likelihood = observedIOR ? pFunc : (1 - pFunc);
            newPosterior[t][s] = psi.posterior[t][s] * likelihood;
            totalProb += newPosterior[t][s];
        }
    }

    // Normalize
    for (let t = 0; t < nThresh; t++) {
        for (let s = 0; s < nSlope; s++) {
            newPosterior[t][s] /= totalProb;
        }
    }

    psi.posterior = newPosterior;
    psi.nObservations++;
    psi.isiHistory.push(isi);
    psi.observationHistory.push(observedIOR ? 1 : 0);
}

// Get posterior mean for threshold
function getThresholdEstimate() {
    const nThresh = thresholdLevels.length;
    const nSlope = slopeLevels.length;

    let meanThreshold = 0;
    for (let t = 0; t < nThresh; t++) {
        let marginalProb = 0;
        for (let s = 0; s < nSlope; s++) {
            marginalProb += psi.posterior[t][s];
        }
        meanThreshold += thresholdLevels[t] * marginalProb;
    }

    return meanThreshold;
}

// Get posterior standard deviation for threshold
function getThresholdSD() {
    const nThresh = thresholdLevels.length;
    const nSlope = slopeLevels.length;
    const mean = getThresholdEstimate();

    let variance = 0;
    for (let t = 0; t < nThresh; t++) {
        let marginalProb = 0;
        for (let s = 0; s < nSlope; s++) {
            marginalProb += psi.posterior[t][s];
        }
        variance += marginalProb * Math.pow(thresholdLevels[t] - mean, 2);
    }

    return Math.sqrt(variance);
}

// Get slope estimate
function getSlopeEstimate() {
    const nThresh = thresholdLevels.length;
    const nSlope = slopeLevels.length;

    let meanSlope = 0;
    for (let s = 0; s < nSlope; s++) {
        let marginalProb = 0;
        for (let t = 0; t < nThresh; t++) {
            marginalProb += psi.posterior[t][s];
        }
        meanSlope += slopeLevels[s] * marginalProb;
    }

    return meanSlope;
}

// Check if posterior is sufficiently concentrated
function isPsiFinished() {
    if (psi.nObservations < N_TRIALS_MIN) return false;
    if (psi.nObservations >= N_TRIALS_MAX) return true;

    // Check if posterior SD is small enough
    const sd = getThresholdSD();
    return sd < 20;  // Stop if SD < 20ms
}

// Check if we have enough RTs to make an observation
function hasEnoughRTs() {
    return psi.validRTs.length >= RT_WINDOW && psi.invalidRTs.length >= RT_WINDOW;
}

// Make observation and update Psi
function makeObservation() {
    const meanValid = psi.validRTs.slice(-RT_WINDOW).reduce((a, b) => a + b, 0) / RT_WINDOW;
    const meanInvalid = psi.invalidRTs.slice(-RT_WINDOW).reduce((a, b) => a + b, 0) / RT_WINDOW;

    // IOR = valid RT >= invalid RT (slower to respond at cued location)
    const observedIOR = meanValid >= meanInvalid;

    updatePosterior(psi.currentISI, observedIOR);

    // Clear RT buffers after observation
    psi.validRTs = [];
    psi.invalidRTs = [];

    // Select next optimal ISI
    psi.currentISI = selectOptimalISI();

    console.log(`Observation ${psi.nObservations}: ISI=${psi.isiHistory[psi.isiHistory.length-1]}ms, ` +
                `IOR=${observedIOR}, Threshold=${getThresholdEstimate().toFixed(1)}ms (SD=${getThresholdSD().toFixed(1)})`);

    return observedIOR;
}

// Initialize Psi on load
initializePsi();

// =============================================================================
// TRIAL MANAGEMENT
// =============================================================================

let currentTrial = {
    cueSide: 'left',
    targetSide: 'left',
    validity: 'valid',
    correctResponse: 'f',
    isi: 200,
    isPractice: false
};

let mainTrialCount = 0;
let practiceTrialCount = 0;

// Generate trial stimulus HTML
function generateTrialHTML(phase) {
    if (phase === 'iti') {
        return '<div class="trial-container"></div>';
    }

    let html = '<div class="trial-container">';
    html += '<div class="fixation">+</div>';
    html += '<div class="box left-box"></div>';
    html += '<div class="box right-box"></div>';

    if (phase === 'cue') {
        html += `<div class="cue cue-${currentTrial.cueSide}"></div>`;
    }

    if (phase === 'target') {
        html += `<div class="target target-${currentTrial.targetSide}"></div>`;
    }

    html += '</div>';
    return html;
}

function setupNewTrial(isPractice) {
    currentTrial.isPractice = isPractice;
    currentTrial.cueSide = Math.random() < 0.5 ? 'left' : 'right';
    currentTrial.validity = Math.random() < 0.5 ? 'valid' : 'invalid';
    currentTrial.targetSide = currentTrial.validity === 'valid' ?
        currentTrial.cueSide :
        (currentTrial.cueSide === 'left' ? 'right' : 'left');
    currentTrial.correctResponse = currentTrial.targetSide === 'left' ? 'f' : 'j';

    if (isPractice) {
        currentTrial.isi = PRACTICE_ISIS[Math.floor(Math.random() * PRACTICE_ISIS.length)];
    } else {
        currentTrial.isi = psi.currentISI;
    }
}

// =============================================================================
// INITIALIZE JSPSYCH
// =============================================================================
const jsPsych = initJsPsych({
    on_finish: function() {
        const threshold = getThresholdEstimate();
        const sd = getThresholdSD();
        console.log('Experiment complete!');
        console.log('Estimated crossover ISI:', threshold.toFixed(1), 'ms');
        console.log('Posterior SD:', sd.toFixed(1), 'ms');
        console.log('Total observations:', psi.nObservations);
    }
});

// =============================================================================
// EXPERIMENT TIMELINE
// =============================================================================
let timeline = [];

// --- Fullscreen ---
timeline.push({
    type: jsPsychFullscreen,
    fullscreen_mode: true,
    message: '<p style="color: white; font-size: 20px;">The experiment will switch to fullscreen mode.<br><br>Click the button below to continue.</p>',
    button_label: 'Enter Fullscreen'
});

// --- Instructions ---
timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
        <div class="instructions">
            <h2>PSI METHOD IOR CROSSOVER EXPERIMENT</h2>
            <p>Focus your eyes on the <strong>plus sign (+)</strong> at all times.</p>
            <p>Two white squares will appear one after the other:</p>
            <ul>
                <li>The <strong>first square</strong> is the cue - <em>ignore it</em></li>
                <li>The <strong>second square</strong> is the target - <em>respond to it</em></li>
            </ul>
            <p><strong>Your task:</strong></p>
            <ul>
                <li>Press <strong>F</strong> if the target appears in the <strong>LEFT</strong> box</li>
                <li>Press <strong>J</strong> if the target appears in the <strong>RIGHT</strong> box</li>
            </ul>
            <p>Respond as <strong>QUICKLY</strong> and <strong>ACCURATELY</strong> as possible.</p>
            <p class="continue-text">Press SPACE to continue</p>
        </div>
    `,
    choices: [' ']
});

// --- Practice Instructions ---
timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
        <div class="instructions">
            <h2>PRACTICE TRIALS</h2>
            <p>You will now have ${N_PRACTICE_TRIALS} practice trials.</p>
            <p>Remember:</p>
            <ul>
                <li>Keep your eyes on the + sign</li>
                <li>Respond only to the second square (target)</li>
                <li>Press <strong>F</strong> for LEFT, <strong>J</strong> for RIGHT</li>
            </ul>
            <p class="continue-text">Press F or J to start practice</p>
        </div>
    `,
    choices: ['f', 'j']
});

// --- Practice Trial Procedure ---
const practiceTrialProcedure = {
    timeline: [
        {
            type: jsPsychCallFunction,
            func: function() {
                setupNewTrial(true);
                practiceTrialCount++;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('fixation'); },
            choices: "NO_KEYS",
            trial_duration: FIXATION_DURATION
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('cue'); },
            choices: "NO_KEYS",
            trial_duration: CUE_DURATION
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('fixation'); },
            choices: "NO_KEYS",
            trial_duration: function() { return currentTrial.isi; }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('target'); },
            choices: ['f', 'j'],
            trial_duration: TARGET_DURATION,
            data: { trial_type: 'ior-trial', practice: true },
            on_finish: function(data) {
                data.cueSide = currentTrial.cueSide;
                data.targetSide = currentTrial.targetSide;
                data.validity = currentTrial.validity;
                data.correctResponse = currentTrial.correctResponse;
                data.isi = currentTrial.isi;
                data.correct = data.response === currentTrial.correctResponse;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() {
                const lastTrial = jsPsych.data.get().last(1).values()[0];
                if (lastTrial.response === null) {
                    return '<div class="feedback error">Too slow! Respond faster.</div>';
                } else if (!lastTrial.correct) {
                    return '<div class="feedback error">Incorrect! F = Left, J = Right</div>';
                }
                return '';
            },
            choices: "NO_KEYS",
            trial_duration: function() {
                const lastTrial = jsPsych.data.get().last(1).values()[0];
                return (lastTrial.response === null || !lastTrial.correct) ? 1500 : 0;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('iti'); },
            choices: "NO_KEYS",
            trial_duration: 750
        }
    ],
    loop_function: function() {
        return practiceTrialCount < N_PRACTICE_TRIALS;
    }
};
timeline.push(practiceTrialProcedure);

// --- Main Experiment Instructions ---
timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
        <div class="instructions">
            <h2>MAIN EXPERIMENT</h2>
            <p>Practice complete! The main experiment will now begin.</p>
            <p>This experiment uses an adaptive algorithm that learns from your responses.</p>
            <p>It will typically finish in 30-50 trials.</p>
            <p class="continue-text">Press F or J to start</p>
        </div>
    `,
    choices: ['f', 'j']
});

// --- Main Trial Procedure ---
const mainTrialProcedure = {
    timeline: [
        {
            type: jsPsychCallFunction,
            func: function() {
                setupNewTrial(false);
                mainTrialCount++;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('fixation'); },
            choices: "NO_KEYS",
            trial_duration: FIXATION_DURATION
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('cue'); },
            choices: "NO_KEYS",
            trial_duration: CUE_DURATION
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('fixation'); },
            choices: "NO_KEYS",
            trial_duration: function() { return currentTrial.isi; }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('target'); },
            choices: ['f', 'j'],
            trial_duration: TARGET_DURATION,
            data: { trial_type: 'ior-trial', practice: false },
            on_finish: function(data) {
                data.trialNum = mainTrialCount;
                data.cueSide = currentTrial.cueSide;
                data.targetSide = currentTrial.targetSide;
                data.validity = currentTrial.validity;
                data.correctResponse = currentTrial.correctResponse;
                data.isi = currentTrial.isi;
                data.correct = data.response === currentTrial.correctResponse;
                data.nObservations = psi.nObservations;
                data.thresholdEstimate = getThresholdEstimate();
                data.thresholdSD = getThresholdSD();
                data.madeObservation = false;

                // Collect RT for valid correct responses
                if (data.correct && data.rt !== null && data.rt > 100) {
                    if (currentTrial.validity === 'valid') {
                        psi.validRTs.push(data.rt);
                    } else {
                        psi.invalidRTs.push(data.rt);
                    }

                    // Check if we have enough RTs to make an observation
                    if (hasEnoughRTs()) {
                        const observedIOR = makeObservation();
                        data.madeObservation = true;
                        data.observedIOR = observedIOR;
                        data.nObservations = psi.nObservations;
                        data.thresholdEstimate = getThresholdEstimate();
                        data.thresholdSD = getThresholdSD();
                    }
                }
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() {
                const lastTrial = jsPsych.data.get().last(1).values()[0];
                if (lastTrial.response === null) {
                    return '<div class="feedback error">Too slow!</div>';
                } else if (!lastTrial.correct) {
                    return '<div class="feedback error">Incorrect!</div>';
                }
                return '';
            },
            choices: "NO_KEYS",
            trial_duration: function() {
                const lastTrial = jsPsych.data.get().last(1).values()[0];
                return (lastTrial.response === null || !lastTrial.correct) ? 500 : 0;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('iti'); },
            choices: "NO_KEYS",
            trial_duration: 750
        }
    ],
    loop_function: function() {
        return !isPsiFinished() && mainTrialCount < N_TRIALS_MAX * 3; // Allow more trials for RT collection
    }
};
timeline.push(mainTrialProcedure);

// --- Results Screen ---
timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: function() {
        const threshold = getThresholdEstimate();
        const sd = getThresholdSD();
        const slope = getSlopeEstimate();

        return `
            <div class="results">
                <h2>EXPERIMENT COMPLETE</h2>
                <p>Total trials: ${mainTrialCount}</p>
                <p>Bayesian observations: ${psi.nObservations}</p>
                <br>
                <p><strong>Estimated IOR crossover point:</strong></p>
                <p style="font-size: 36px; color: #66ff66;">${threshold.toFixed(1)} ms ISI</p>
                <p style="color: #aaa;">95% CI: ${(threshold - 2*sd).toFixed(0)} - ${(threshold + 2*sd).toFixed(0)} ms</p>
                <p style="color: #888;">Posterior SD: ${sd.toFixed(1)} ms</p>
                <p style="color: #888;">Slope estimate: ${slope.toFixed(1)} ms</p>
                <br>
                <p>Thank you for participating!</p>
                <p style="color: #aaa; margin-top: 30px;">Press SPACE to finish and download data</p>
            </div>
        `;
    },
    choices: [' '],
    on_finish: function() {
        const allTrials = jsPsych.data.get().values();
        const mainTrials = allTrials.filter(trial =>
            trial.trial_type === 'ior-trial' && trial.practice === false
        );

        const headers = ['trialNum', 'isi', 'validity', 'rt', 'correct', 'response',
                        'cueSide', 'targetSide', 'madeObservation', 'observedIOR',
                        'nObservations', 'thresholdEstimate', 'thresholdSD'];
        let csvContent = headers.join(',') + '\n';

        mainTrials.forEach(trial => {
            const row = [
                trial.trialNum !== undefined ? trial.trialNum : '',
                trial.isi !== undefined ? trial.isi : '',
                trial.validity !== undefined ? trial.validity : '',
                trial.rt !== null && trial.rt !== undefined ? trial.rt : '',
                trial.correct !== undefined ? trial.correct : '',
                trial.response !== null && trial.response !== undefined ? trial.response : '',
                trial.cueSide !== undefined ? trial.cueSide : '',
                trial.targetSide !== undefined ? trial.targetSide : '',
                trial.madeObservation !== undefined ? trial.madeObservation : '',
                trial.observedIOR !== undefined ? trial.observedIOR : '',
                trial.nObservations !== undefined ? trial.nObservations : '',
                trial.thresholdEstimate !== undefined ? trial.thresholdEstimate.toFixed(2) : '',
                trial.thresholdSD !== undefined ? trial.thresholdSD.toFixed(2) : ''
            ];
            csvContent += row.join(',') + '\n';
        });

        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `psi_crossover_ior_${Date.now()}.csv`;
        a.click();
    }
});

// --- Exit Fullscreen ---
timeline.push({
    type: jsPsychFullscreen,
    fullscreen_mode: false
});

// =============================================================================
// RUN EXPERIMENT
// =============================================================================
jsPsych.run(timeline);
</script>
</html>
