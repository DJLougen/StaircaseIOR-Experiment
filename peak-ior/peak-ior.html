<!DOCTYPE html>
<html>
<head>
    <title>Peak IOR Experiment</title>
    <script src="https://unpkg.com/jspsych@7.3.4"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-fullscreen@1.2.1"></script>
    <script src="https://unpkg.com/@jspsych/plugin-call-function@1.1.3"></script>
    <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" type="text/css" />
    <style>
        body {
            background-color: black;
        }
        .jspsych-content {
            max-width: 100%;
        }
        .jspsych-content-wrapper {
            background-color: black;
        }
        .trial-container {
            position: relative;
            width: 800px;
            height: 400px;
            margin: 0 auto;
            background-color: black;
        }
        .fixation {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: white;
            font-family: Arial, sans-serif;
        }
        .box {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 3px solid white;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
        }
        .left-box {
            left: 150px;
        }
        .right-box {
            right: 150px;
        }
        .cue, .target {
            position: absolute;
            width: 74px;
            height: 74px;
            background-color: white;
            top: 50%;
            transform: translateY(-50%);
        }
        .cue-left, .target-left {
            left: 153px;
        }
        .cue-right, .target-right {
            right: 153px;
        }
        .instructions {
            color: white;
            font-size: 20px;
            line-height: 1.6;
            max-width: 700px;
            margin: 0 auto;
            text-align: left;
        }
        .instructions h2 {
            text-align: center;
        }
        .continue-text {
            text-align: center;
            margin-top: 30px;
            color: #aaa;
        }
        .feedback {
            color: white;
            font-size: 32px;
            text-align: center;
        }
        .feedback.error {
            color: #ff6666;
        }
        .results {
            color: white;
            font-size: 24px;
            line-height: 1.8;
            text-align: center;
        }
    </style>
</head>
<body></body>
<script>
// =============================================================================
// PEAK IOR EXPERIMENT - jsPsych Version
// =============================================================================
// This experiment uses an adaptive staircase to find the ISI that produces
// the MAXIMUM IOR effect (largest RT difference: invalid - valid).
//
// ISI = Inter-Stimulus Interval (gap between cue offset and target onset)
//
// Unlike the crossover experiment (which finds where IOR = 0), this finds
// where IOR is strongest.
//
// Strategy: Use a "hill-climbing" approach that tracks the IOR magnitude
// and moves toward ISIs that produce larger effects.
// =============================================================================

// --- Staircase Parameters ---
// ISI = Inter-Stimulus Interval (gap between cue offset and target onset)
const MIN_ISI = 100;      // 100ms minimum (past facilitation zone)
const MAX_ISI = 800;      // 800ms maximum
const START_ISI = 300;    // Starting point (typical peak IOR region)
const STEP_SIZE_INITIAL = 75;   // 75ms initial step
const STEP_SIZE_MIN = 15;       // 15ms minimum step
const N_REVERSALS = 14;         // Reversals before stopping
const N_REVERSALS_BEFORE_SHRINK = 5;  // Keep step size constant for first N reversals
const N_TRIALS_MAX = 250;       // Maximum trials
const RT_WINDOW = 6;            // Trials to average for comparison (more for stability)

// --- Timing Parameters (in ms) ---
const FIXATION_DURATION = 750;
const CUE_DURATION = 50;
const TARGET_DURATION = 1000;

// --- Practice Parameters ---
const N_PRACTICE_TRIALS = 0;  // Disabled for testing
const PRACTICE_ISIS = [150, 300, 450];

// --- Sampling Phase Parameters ---
// Sample 5 ISIs across the range to find good starting point
const SAMPLING_ISIS = [100, 275, 450, 625, 800];
const N_SAMPLING_REPS = 5;  // 5 trials per ISI (will be mixed valid/invalid)

// --- Staircase State ---
let staircase = {
    currentISI: START_ISI,
    stepSize: STEP_SIZE_INITIAL,
    validRTs: [],       // Array of {isi, rt}
    invalidRTs: [],     // Array of {isi, rt}
    isiHistory: [],
    iorHistory: [],     // IOR magnitude at each update
    reversals: [],
    lastDirection: null,
    lastIOR: null,      // Previous IOR magnitude for comparison
};

// --- Current Trial Variables ---
let currentTrial = {
    cueSide: 'left',
    targetSide: 'left',
    validity: 'valid',
    correctResponse: 'f',
    isi: 300,
    isPractice: false
};

// --- Trial Counter ---
let mainTrialCount = 0;
let practiceTrialCount = 0;
let samplingTrialCount = 0;

// --- Sampling Phase State ---
let samplingData = {
    trials: [],  // All sampling trials: {isi, validity, rt, correct}
    schedule: [] // Pre-generated randomized trial order
};

// Generate sampling trial schedule
function generateSamplingSchedule() {
    const schedule = [];
    // For each ISI, create N_SAMPLING_REPS trials
    // Half valid, half invalid (or as close as possible)
    for (const isi of SAMPLING_ISIS) {
        for (let i = 0; i < N_SAMPLING_REPS; i++) {
            schedule.push({
                isi: isi,
                validity: i < Math.ceil(N_SAMPLING_REPS / 2) ? 'valid' : 'invalid'
            });
        }
    }
    // Shuffle the schedule
    for (let i = schedule.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [schedule[i], schedule[j]] = [schedule[j], schedule[i]];
    }
    return schedule;
}

// Calculate IOR for each sampled ISI and find the best starting point
function findBestStartingISI() {
    const iorByISI = {};

    // Group trials by ISI
    for (const isi of SAMPLING_ISIS) {
        const isiTrials = samplingData.trials.filter(t => t.isi === isi && t.correct && t.rt > 100);
        const validRTs = isiTrials.filter(t => t.validity === 'valid').map(t => t.rt);
        const invalidRTs = isiTrials.filter(t => t.validity === 'invalid').map(t => t.rt);

        if (validRTs.length > 0 && invalidRTs.length > 0) {
            const meanValid = validRTs.reduce((a, b) => a + b, 0) / validRTs.length;
            const meanInvalid = invalidRTs.reduce((a, b) => a + b, 0) / invalidRTs.length;
            // IOR = valid RT - invalid RT (positive = IOR present)
            iorByISI[isi] = meanValid - meanInvalid;
        } else {
            iorByISI[isi] = 0;
        }
    }

    console.log('Sampling phase IOR by ISI:', iorByISI);

    // Find ISI with maximum IOR
    let bestISI = START_ISI;
    let maxIOR = -Infinity;
    for (const [isi, ior] of Object.entries(iorByISI)) {
        if (ior > maxIOR) {
            maxIOR = ior;
            bestISI = parseInt(isi);
        }
    }

    console.log(`Best starting ISI from sampling: ${bestISI}ms (IOR = ${maxIOR.toFixed(1)}ms)`);
    return bestISI;
}

// --- Helper Functions ---
function getRecentRTs(n = RT_WINDOW) {
    // Get RTs near the current ISI (within 100ms)
    const isiTolerance = 100;
    const currentISI = staircase.currentISI;

    const recentValid = staircase.validRTs
        .filter(x => Math.abs(x.isi - currentISI) <= isiTolerance)
        .slice(-n)
        .map(x => x.rt);

    const recentInvalid = staircase.invalidRTs
        .filter(x => Math.abs(x.isi - currentISI) <= isiTolerance)
        .slice(-n)
        .map(x => x.rt);

    return { recentValid, recentInvalid };
}

function calculateIOR() {
    const { recentValid, recentInvalid } = getRecentRTs(RT_WINDOW);

    if (recentValid.length < 3 || recentInvalid.length < 3) {
        return null;
    }

    const meanValid = recentValid.reduce((a, b) => a + b, 0) / recentValid.length;
    const meanInvalid = recentInvalid.reduce((a, b) => a + b, 0) / recentInvalid.length;

    // IOR magnitude = valid RT - invalid RT (positive = IOR present)
    return meanValid - meanInvalid;
}

function shouldUpdateStaircase() {
    const { recentValid, recentInvalid } = getRecentRTs(RT_WINDOW);
    return recentValid.length >= 3 && recentInvalid.length >= 3;
}

function updateStaircase() {
    const currentIOR = calculateIOR();

    if (currentIOR === null) {
        return { newISI: staircase.currentISI, reversal: false };
    }

    staircase.iorHistory.push({ isi: staircase.currentISI, ior: currentIOR });
    staircase.isiHistory.push(staircase.currentISI);

    let reversal = false;
    let newDirection = null;

    // If we don't have a previous IOR to compare, just pick a direction
    if (staircase.lastIOR === null) {
        // Start by going up (toward longer ISIs)
        newDirection = 'up';
        staircase.currentISI = Math.min(MAX_ISI, staircase.currentISI + staircase.stepSize);
        staircase.lastDirection = newDirection;
        staircase.lastIOR = currentIOR;
        return { newISI: staircase.currentISI, reversal: false };
    }

    // Compare current IOR to previous
    const iorIncreased = currentIOR > staircase.lastIOR;
    const iorDecreased = currentIOR < staircase.lastIOR;

    // If IOR increased, keep going in the same direction
    // If IOR decreased, reverse direction (we overshot the peak)
    if (iorDecreased) {
        // We moved away from the peak, reverse!
        if (staircase.lastDirection === 'up') {
            newDirection = 'down';
        } else {
            newDirection = 'up';
        }
        reversal = true;
        staircase.reversals.push(staircase.currentISI);
        // Only shrink step size after N_REVERSALS_BEFORE_SHRINK (exploration phase complete)
        if (staircase.reversals.length > N_REVERSALS_BEFORE_SHRINK) {
            staircase.stepSize = Math.max(STEP_SIZE_MIN, staircase.stepSize * 0.7);
        }
    } else {
        // IOR increased or stayed same, keep going
        newDirection = staircase.lastDirection || 'up';
    }

    // Apply the step (1-up 3-down: increment by 1x, decrement by 3x)
    if (newDirection === 'up') {
        staircase.currentISI = Math.min(MAX_ISI, staircase.currentISI + staircase.stepSize);
    } else {
        staircase.currentISI = Math.max(MIN_ISI, staircase.currentISI - (3 * staircase.stepSize));
    }

    staircase.lastDirection = newDirection;
    staircase.lastIOR = currentIOR;

    return { newISI: staircase.currentISI, reversal };
}

function isStaircaseFinished() {
    return staircase.reversals.length >= N_REVERSALS;
}

function getPeakISI() {
    // Find the ISI with the maximum IOR from our history
    if (staircase.iorHistory.length < 4) {
        return staircase.currentISI;
    }

    // Use last several reversals as the estimate
    if (staircase.reversals.length >= 4) {
        const nUse = Math.min(10, staircase.reversals.length);
        const lastReversals = staircase.reversals.slice(-nUse);
        return lastReversals.reduce((a, b) => a + b, 0) / lastReversals.length;
    }

    // Fallback: find max IOR in history
    let maxIOR = -Infinity;
    let peakISI = staircase.currentISI;
    for (const entry of staircase.iorHistory) {
        if (entry.ior > maxIOR) {
            maxIOR = entry.ior;
            peakISI = entry.isi;
        }
    }
    return peakISI;
}

function getMaxIOR() {
    if (staircase.iorHistory.length === 0) return 0;
    return Math.max(...staircase.iorHistory.map(x => x.ior));
}

// Generate trial stimulus HTML
function generateTrialHTML(phase) {
    // Blank ITI screen - no fixation, no boxes
    if (phase === 'iti') {
        return '<div class="trial-container"></div>';
    }

    let html = '<div class="trial-container">';
    html += '<div class="fixation">+</div>';
    html += '<div class="box left-box"></div>';
    html += '<div class="box right-box"></div>';

    if (phase === 'cue') {
        html += `<div class="cue cue-${currentTrial.cueSide}"></div>`;
    }

    if (phase === 'target') {
        html += `<div class="target target-${currentTrial.targetSide}"></div>`;
    }

    html += '</div>';
    return html;
}

// Setup a new trial
function setupNewTrial(isPractice, isSampling = false) {
    currentTrial.isPractice = isPractice;
    currentTrial.cueSide = Math.random() < 0.5 ? 'left' : 'right';

    if (isSampling) {
        // Sampling trial - use pre-generated schedule
        const scheduledTrial = samplingData.schedule[samplingTrialCount];
        currentTrial.validity = scheduledTrial.validity;
        currentTrial.isi = scheduledTrial.isi;
    } else if (isPractice) {
        currentTrial.validity = Math.random() < 0.5 ? 'valid' : 'invalid';
        currentTrial.isi = PRACTICE_ISIS[Math.floor(Math.random() * PRACTICE_ISIS.length)];
    } else {
        currentTrial.validity = Math.random() < 0.5 ? 'valid' : 'invalid';
        currentTrial.isi = staircase.currentISI;
    }

    currentTrial.targetSide = currentTrial.validity === 'valid' ?
        currentTrial.cueSide :
        (currentTrial.cueSide === 'left' ? 'right' : 'left');
    currentTrial.correctResponse = currentTrial.targetSide === 'left' ? 'f' : 'j';
}

// =============================================================================
// INITIALIZE JSPSYCH
// =============================================================================
const jsPsych = initJsPsych({
    on_finish: function() {
        const peakISI = getPeakISI();
        const maxIOR = getMaxIOR();
        console.log('Experiment complete!');
        console.log('Peak IOR ISI:', peakISI.toFixed(1), 'ms');
        console.log('Max IOR magnitude:', maxIOR.toFixed(1), 'ms');
        console.log('Total reversals:', staircase.reversals.length);
    }
});

// =============================================================================
// EXPERIMENT TIMELINE
// =============================================================================
let timeline = [];

// --- Fullscreen ---
timeline.push({
    type: jsPsychFullscreen,
    fullscreen_mode: true,
    message: '<p style="color: white; font-size: 20px;">The experiment will switch to fullscreen mode.<br><br>Click the button below to continue.</p>',
    button_label: 'Enter Fullscreen'
});

// --- Instructions ---
timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
        <div class="instructions">
            <h2>PEAK IOR EXPERIMENT</h2>
            <p>Focus your eyes on the <strong>plus sign (+)</strong> at all times.</p>
            <p>Two white squares will appear one after the other:</p>
            <ul>
                <li>The <strong>first square</strong> is the cue — <em>ignore it</em></li>
                <li>The <strong>second square</strong> is the target — <em>respond to it</em></li>
            </ul>
            <p><strong>Your task:</strong></p>
            <ul>
                <li>Press <strong>F</strong> if the target appears in the <strong>LEFT</strong> box</li>
                <li>Press <strong>J</strong> if the target appears in the <strong>RIGHT</strong> box</li>
            </ul>
            <p>Respond as <strong>QUICKLY</strong> and <strong>ACCURATELY</strong> as possible.</p>
            <p class="continue-text">Press SPACE to continue</p>
        </div>
    `,
    choices: [' ']
});

// --- Practice Instructions ---
timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
        <div class="instructions">
            <h2>PRACTICE TRIALS</h2>
            <p>You will now have ${N_PRACTICE_TRIALS} practice trials.</p>
            <p>Remember:</p>
            <ul>
                <li>Keep your eyes on the + sign</li>
                <li>Respond only to the second square (target)</li>
                <li>Press <strong>F</strong> for LEFT, <strong>J</strong> for RIGHT</li>
            </ul>
            <p class="continue-text">Press F or J to start practice</p>
        </div>
    `,
    choices: ['f', 'j']
});

// --- Practice Trial Procedure ---
const practiceTrialProcedure = {
    timeline: [
        {
            type: jsPsychCallFunction,
            func: function() {
                setupNewTrial(true);
                practiceTrialCount++;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('fixation'); },
            choices: "NO_KEYS",
            trial_duration: FIXATION_DURATION
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('cue'); },
            choices: "NO_KEYS",
            trial_duration: CUE_DURATION
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('fixation'); },
            choices: "NO_KEYS",
            trial_duration: function() {
                return currentTrial.isi;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('target'); },
            choices: ['f', 'j'],
            trial_duration: TARGET_DURATION,
            data: {
                trial_type: 'ior-trial',
                practice: true
            },
            on_finish: function(data) {
                data.cueSide = currentTrial.cueSide;
                data.targetSide = currentTrial.targetSide;
                data.validity = currentTrial.validity;
                data.correctResponse = currentTrial.correctResponse;
                data.isi = currentTrial.isi;
                data.correct = data.response === currentTrial.correctResponse;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() {
                const lastTrial = jsPsych.data.get().last(1).values()[0];
                if (lastTrial.response === null) {
                    return '<div class="feedback error">Too slow! Respond faster.</div>';
                } else if (!lastTrial.correct) {
                    return '<div class="feedback error">Incorrect! F = Left, J = Right</div>';
                }
                return '';
            },
            choices: "NO_KEYS",
            trial_duration: function() {
                const lastTrial = jsPsych.data.get().last(1).values()[0];
                return (lastTrial.response === null || !lastTrial.correct) ? 1500 : 0;
            }
        },
        // ITI - blank screen between trials
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('iti'); },
            choices: "NO_KEYS",
            trial_duration: 750
        }
    ],
    loop_function: function() {
        return practiceTrialCount < N_PRACTICE_TRIALS;
    }
};
timeline.push(practiceTrialProcedure);

// --- Sampling Phase Instructions ---
timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
        <div class="instructions">
            <h2>SAMPLING PHASE</h2>
            <p>Practice complete! Now we'll run a brief sampling phase.</p>
            <p>This helps calibrate the experiment to your responses.</p>
            <p>You'll complete ${SAMPLING_ISIS.length * N_SAMPLING_REPS} trials.</p>
            <p class="continue-text">Press F or J to start sampling</p>
        </div>
    `,
    choices: ['f', 'j'],
    on_start: function() {
        // Generate the randomized sampling schedule
        samplingData.schedule = generateSamplingSchedule();
        console.log('Sampling schedule generated:', samplingData.schedule.length, 'trials');
    }
});

// --- Sampling Trial Procedure ---
const samplingTrialProcedure = {
    timeline: [
        {
            type: jsPsychCallFunction,
            func: function() {
                setupNewTrial(false, true);  // not practice, is sampling
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('fixation'); },
            choices: "NO_KEYS",
            trial_duration: FIXATION_DURATION
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('cue'); },
            choices: "NO_KEYS",
            trial_duration: CUE_DURATION
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('fixation'); },
            choices: "NO_KEYS",
            trial_duration: function() {
                return currentTrial.isi;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('target'); },
            choices: ['f', 'j'],
            trial_duration: TARGET_DURATION,
            data: {
                trial_type: 'ior-trial',
                practice: false,
                sampling: true
            },
            on_finish: function(data) {
                data.samplingTrialNum = samplingTrialCount + 1;
                data.cueSide = currentTrial.cueSide;
                data.targetSide = currentTrial.targetSide;
                data.validity = currentTrial.validity;
                data.correctResponse = currentTrial.correctResponse;
                data.isi = currentTrial.isi;
                data.correct = data.response === currentTrial.correctResponse;

                // Store sampling data
                samplingData.trials.push({
                    isi: currentTrial.isi,
                    validity: currentTrial.validity,
                    rt: data.rt,
                    correct: data.correct
                });

                samplingTrialCount++;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() {
                const lastTrial = jsPsych.data.get().last(1).values()[0];
                if (lastTrial.response === null) {
                    return '<div class="feedback error">Too slow!</div>';
                } else if (!lastTrial.correct) {
                    return '<div class="feedback error">Incorrect!</div>';
                }
                return '';
            },
            choices: "NO_KEYS",
            trial_duration: function() {
                const lastTrial = jsPsych.data.get().last(1).values()[0];
                return (lastTrial.response === null || !lastTrial.correct) ? 500 : 0;
            }
        },
        // ITI - blank screen between trials
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('iti'); },
            choices: "NO_KEYS",
            trial_duration: 750
        }
    ],
    loop_function: function() {
        return samplingTrialCount < samplingData.schedule.length;
    }
};
timeline.push(samplingTrialProcedure);

// --- Set staircase starting point based on sampling ---
timeline.push({
    type: jsPsychCallFunction,
    func: function() {
        const bestISI = findBestStartingISI();
        staircase.currentISI = bestISI;
        console.log('Staircase starting ISI set to:', bestISI);
    }
});

// --- Main Experiment Instructions ---
timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: function() {
        return `
            <div class="instructions">
                <h2>MAIN EXPERIMENT</h2>
                <p>Sampling complete! The adaptive staircase will now begin.</p>
                <p>Starting ISI: ${staircase.currentISI}ms</p>
                <p>The task will adapt based on your responses.</p>
                <p>Continue until you see the completion screen.</p>
                <p class="continue-text">Press F or J to start</p>
            </div>
        `;
    },
    choices: ['f', 'j']
});

// --- Main Trial Procedure ---
const mainTrialProcedure = {
    timeline: [
        {
            type: jsPsychCallFunction,
            func: function() {
                setupNewTrial(false);
                mainTrialCount++;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('fixation'); },
            choices: "NO_KEYS",
            trial_duration: FIXATION_DURATION
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('cue'); },
            choices: "NO_KEYS",
            trial_duration: CUE_DURATION
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('fixation'); },
            choices: "NO_KEYS",
            trial_duration: function() {
                return currentTrial.isi;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('target'); },
            choices: ['f', 'j'],
            trial_duration: TARGET_DURATION,
            data: {
                trial_type: 'ior-trial',
                practice: false
            },
            on_finish: function(data) {
                data.trialNum = mainTrialCount;
                data.cueSide = currentTrial.cueSide;
                data.targetSide = currentTrial.targetSide;
                data.validity = currentTrial.validity;
                data.correctResponse = currentTrial.correctResponse;
                data.isi = currentTrial.isi;
                data.correct = data.response === currentTrial.correctResponse;
                data.nReversals = staircase.reversals.length;
                data.stepSize = staircase.stepSize;
                data.currentISI = staircase.currentISI;
                data.currentIOR = staircase.lastIOR || 0;
                data.reversal = false;

                // Update staircase for correct trials with valid RTs
                if (data.correct && data.rt !== null && data.rt > 100) {
                    if (currentTrial.validity === 'valid') {
                        staircase.validRTs.push({ isi: currentTrial.isi, rt: data.rt });
                    } else {
                        staircase.invalidRTs.push({ isi: currentTrial.isi, rt: data.rt });
                    }

                    if (shouldUpdateStaircase()) {
                        const { reversal } = updateStaircase();
                        data.reversal = reversal;
                        data.currentIOR = staircase.lastIOR || 0;
                        data.nReversals = staircase.reversals.length;
                        if (reversal) {
                            console.log(`Reversal ${staircase.reversals.length}: ISI = ${staircase.currentISI}ms, IOR = ${staircase.lastIOR?.toFixed(1)}ms`);
                        }
                    }
                }
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() {
                const lastTrial = jsPsych.data.get().last(1).values()[0];
                if (lastTrial.response === null) {
                    return '<div class="feedback error">Too slow!</div>';
                } else if (!lastTrial.correct) {
                    return '<div class="feedback error">Incorrect!</div>';
                }
                return '';
            },
            choices: "NO_KEYS",
            trial_duration: function() {
                const lastTrial = jsPsych.data.get().last(1).values()[0];
                return (lastTrial.response === null || !lastTrial.correct) ? 500 : 0;
            }
        },
        // ITI - blank screen between trials
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() { return generateTrialHTML('iti'); },
            choices: "NO_KEYS",
            trial_duration: 750
        }
    ],
    loop_function: function() {
        return !isStaircaseFinished() && mainTrialCount < N_TRIALS_MAX;
    }
};
timeline.push(mainTrialProcedure);

// --- Results Screen ---
timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: function() {
        const peakISI = getPeakISI();
        const maxIOR = getMaxIOR();

        return `
            <div class="results">
                <h2>EXPERIMENT COMPLETE</h2>
                <p>Sampling trials: ${samplingTrialCount}</p>
                <p>Staircase trials: ${mainTrialCount}</p>
                <p>Reversals: ${staircase.reversals.length}</p>
                <br>
                <p><strong>ISI with Peak IOR:</strong></p>
                <p style="font-size: 36px; color: #66ff66;">${peakISI.toFixed(1)} ms</p>
                <p><strong>Maximum IOR magnitude:</strong></p>
                <p style="font-size: 28px; color: #ffaa66;">${maxIOR.toFixed(1)} ms</p>
                <br>
                <p>Thank you for participating!</p>
                <p style="color: #aaa; margin-top: 30px;">Press SPACE to finish and download data</p>
            </div>
        `;
    },
    choices: [' '],
    on_finish: function() {
        // Get all trial data and filter for non-practice trials (sampling + staircase)
        const allTrials = jsPsych.data.get().values();

        // Debug: log all trials with their properties
        console.log('All trials:', allTrials.length);
        allTrials.forEach((t, i) => {
            if (t.trial_type === 'ior-trial') {
                console.log(`Trial ${i}: type=${t.trial_type}, practice=${t.practice}, sampling=${t.sampling}, trialNum=${t.trialNum}`);
            }
        });

        const experimentTrials = allTrials.filter(trial =>
            trial.trial_type === 'ior-trial' && trial.practice === false
        );

        console.log('Experiment trials found:', experimentTrials.length);

        // Create clean CSV with key columns for plotting
        const headers = ['phase', 'trialNum', 'isi', 'validity', 'rt', 'correct', 'response', 'cueSide', 'targetSide', 'reversal', 'nReversals', 'stepSize', 'currentIOR'];
        let csvContent = headers.join(',') + '\n';

        experimentTrials.forEach(trial => {
            const phase = trial.sampling === true ? 'sampling' : 'staircase';
            const trialNum = trial.sampling === true ? trial.samplingTrialNum : trial.trialNum;
            const row = [
                phase,
                trialNum !== undefined ? trialNum : '',
                trial.isi !== undefined ? trial.isi : '',
                trial.validity !== undefined ? trial.validity : '',
                trial.rt !== null && trial.rt !== undefined ? trial.rt : '',
                trial.correct !== undefined ? trial.correct : '',
                trial.response !== null && trial.response !== undefined ? trial.response : '',
                trial.cueSide !== undefined ? trial.cueSide : '',
                trial.targetSide !== undefined ? trial.targetSide : '',
                trial.reversal !== undefined ? trial.reversal : '',
                trial.nReversals !== undefined ? trial.nReversals : '',
                trial.stepSize !== undefined ? trial.stepSize : '',
                trial.currentIOR !== null && trial.currentIOR !== undefined ? trial.currentIOR.toFixed(1) : ''
            ];
            csvContent += row.join(',') + '\n';
        });

        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `peak_ior_${Date.now()}.csv`;
        a.click();
    }
});

// --- Exit Fullscreen ---
timeline.push({
    type: jsPsychFullscreen,
    fullscreen_mode: false
});

// =============================================================================
// RUN EXPERIMENT
// =============================================================================
jsPsych.run(timeline);
</script>
</html>
